<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Daniel Carrera</title>
    <link rel="icon" type="image/png" href="logo.png">
    <link rel="stylesheet" href="styles.css">
    <script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
</head>
<body>
    <div class="page-flash"></div>
    <canvas id="constellation-bg"></canvas>
    <model-viewer
        id="hero-model"
        src="timeless-gaze-compressed.glb"
        alt="3D Model"
        loading="eager"
        reveal="auto"
        camera-orbit="0deg 90deg auto"
        camera-target="0m 0.15m 0m"
        interaction-prompt="none"
        disable-zoom
        disable-pan
        shadow-intensity="0"
        style="background: transparent !important;"
        class="hero-model"
    ></model-viewer>
    <div id="model-click-overlay"></div>
    <canvas id="constellation-fg"></canvas>
    <nav>
        <a href="/" class="nav-name">
            <img src="logo.png" alt="Logo" class="nav-logo">
            Daniel Carrera
        </a>
        <div class="nav-links">
            <a href="/art.html">Art</a>
            <a href="/literature.html">Literature</a>
            <a href="/software.html">Software</a>
        </div>
    </nav>

    <main>
        <section class="hero">
            <h1>Daniel Carrera</h1>
            <p class="hero-subtitle">polymath</p>
        </section>

        <section class="latest-blog">
            <h2>Latest</h2>
            <a href="/literature.html" class="blog-preview-card">
                <time datetime="2026-01-23">January 23, 2026</time>
                <h3>Your First Blog Post</h3>
                <p>This is where your blog post excerpt will appear. Write about anything that interests you.</p>
            </a>
        </section>

        <section class="projects">
            <h2>Software</h2>

            <div class="project-grid">
                <a href="/software.html#tiempo" class="project-card card-tiempo">
                    <img src="icon-tiempo.png" alt="Tiempo" class="project-icon-img">
                    <h3>Tiempo</h3>
                    <p>AI-Daily Planner for iOS and macOS</p>
                </a>

                <a href="/software.html#synesthesia" class="project-card card-synesthesia">
                    <img src="icon-synesthesia.png" alt="Synesthesia" class="project-icon-img">
                    <h3>Synesthesia</h3>
                    <p>VisionOS app for experiencing music visually</p>
                </a>

                <a href="/software.html#arrow" class="project-card card-arrow">
                    <img src="icon-arrow.png" alt="Arrow" class="project-icon-img">
                    <h3>Arrow</h3>
                    <p>VisionOS app for Spatial Messaging</p>
                </a>
            </div>
        </section>

        <section class="featured-media">
            <h2>Art</h2>
            <a href="/art.html" class="art-grid">
                <div class="art-col art-col-video">
                    <div class="art-item art-video"></div>
                </div>
                <div class="art-col art-col-2">
                    <div class="art-item"></div>
                    <div class="art-item"></div>
                </div>
                <div class="art-col art-col-3">
                    <div class="art-item"></div>
                    <div class="art-item"></div>
                    <div class="art-item"></div>
                </div>
            </a>
        </section>
    </main>

    <footer>
        <p>&copy; 2026 Daniel Carrera</p>
    </footer>
    <script src="animation.js"></script>
    <script>
        // Page transition flash effect
        document.querySelectorAll('nav a').forEach(link => {
            link.addEventListener('click', function(e) {
                if (this.href && !this.href.includes('#')) {
                    e.preventDefault();
                    const flash = document.querySelector('.page-flash');
                    flash.classList.add('active');
                    setTimeout(() => {
                        window.location.href = this.href;
                    }, 150);
                }
            });
        });
    </script>
    <script>
        // Figure-8 infinity motion for 3D model with mouse tracking and drag control
        const heroModel = document.getElementById('hero-model');
        const clickOverlay = document.getElementById('model-click-overlay');
        if (heroModel && clickOverlay) {
            let startTime = null;
            let pausedTime = null;
            const duration = 20000; // 20 seconds for full infinity loop
            let scrollScale = 1;
            let mouseRotation = 0;
            let mouseTilt = 0;
            let isPaused = false;
            let isDragging = false;
            let dragStartX = 0;
            let dragStartY = 0;
            let dragRotation = 0;
            let dragTilt = 90;
            let pausedMoveX = 0;
            let pausedMoveY = 0;
            let pausedScale = 1;

            // Update scale based on scroll position
            function updateScrollScale() {
                const scrollY = window.scrollY;
                const maxScroll = 400;
                scrollScale = 1 + Math.min(scrollY / maxScroll, 1) * 0.5;
            }

            // Track mouse position relative to model center (only when not paused)
            function updateMousePosition(e) {
                if (isPaused || isDragging) return;
                const rect = heroModel.getBoundingClientRect();
                const modelCenterX = rect.left + rect.width / 2;
                const modelCenterY = rect.top + rect.height / 2;
                const deltaX = e.clientX - modelCenterX;
                const deltaY = e.clientY - modelCenterY;
                mouseRotation = Math.atan2(deltaX, 300) * (180 / Math.PI) * -1;
                mouseTilt = Math.atan2(deltaY, 300) * (180 / Math.PI) * -1;
            }

            // Pointer event handlers for click and drag (on overlay)
            let clickStartX = 0;
            let clickStartY = 0;
            let pointerId = null;

            clickOverlay.addEventListener('pointerdown', (e) => {
                clickStartX = e.clientX;
                clickStartY = e.clientY;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                pointerId = e.pointerId;
                clickOverlay.setPointerCapture(e.pointerId);
            });

            clickOverlay.addEventListener('pointermove', (e) => {
                if (pointerId === null) return;

                const dx = Math.abs(e.clientX - clickStartX);
                const dy = Math.abs(e.clientY - clickStartY);

                // Start dragging if moved more than 5px and paused
                if (isPaused && (dx > 5 || dy > 5)) {
                    isDragging = true;
                    clickOverlay.style.cursor = 'grabbing';
                }

                if (isDragging) {
                    const deltaX = e.clientX - dragStartX;
                    const deltaY = e.clientY - dragStartY;
                    dragRotation -= deltaX * 0.5;
                    dragTilt = Math.max(45, Math.min(135, dragTilt - deltaY * 0.5));  // Fixed inversion
                    dragStartX = e.clientX;
                    dragStartY = e.clientY;
                    heroModel.setAttribute('camera-orbit', `${dragRotation}deg ${dragTilt}deg auto`);
                }
            });

            clickOverlay.addEventListener('pointerup', (e) => {
                const dx = Math.abs(e.clientX - clickStartX);
                const dy = Math.abs(e.clientY - clickStartY);

                // If it was a click (not a drag)
                if (dx < 5 && dy < 5) {
                    isPaused = !isPaused;
                    if (isPaused) {
                        pausedTime = performance.now();
                        // Capture exact current position from the animation
                        const elapsed = pausedTime - startTime;
                        const t = (elapsed / duration) * Math.PI * 2;
                        const baseRotation = Math.sin(t) * 25;
                        const tiltOffset = Math.sin(t * 2);
                        const baseTilt = 80 + tiltOffset * 10;
                        dragRotation = baseRotation + mouseRotation;
                        dragTilt = baseTilt + mouseTilt;
                        // Capture transform values
                        pausedMoveX = Math.sin(t) * 10;
                        pausedMoveY = Math.sin(t * 2) * 4;
                        pausedScale = (1 + tiltOffset * 0.15) * scrollScale;
                        clickOverlay.style.cursor = 'grab';
                    } else {
                        if (pausedTime && startTime) {
                            startTime += performance.now() - pausedTime;
                        }
                        clickOverlay.style.cursor = 'pointer';
                    }
                }

                isDragging = false;
                pointerId = null;
                clickOverlay.style.cursor = isPaused ? 'grab' : 'pointer';
                try { clickOverlay.releasePointerCapture(e.pointerId); } catch(err) {}
            });

            window.addEventListener('scroll', updateScrollScale, { passive: true });
            window.addEventListener('mousemove', updateMousePosition, { passive: true });
            updateScrollScale();

            function animateRotation(timestamp) {
                if (!startTime) startTime = timestamp;

                if (!isPaused) {
                    const elapsed = timestamp - startTime;
                    const t = (elapsed / duration) * Math.PI * 2;

                    const baseRotation = Math.sin(t) * 25;
                    const tiltOffset = Math.sin(t * 2);
                    const baseTilt = 80 + tiltOffset * 10;

                    const rotation = baseRotation + mouseRotation;
                    const tilt = baseTilt + mouseTilt;

                    const moveX = Math.sin(t) * 10;
                    const moveY = Math.sin(t * 2) * 4;

                    const nodScale = 1 + tiltOffset * 0.15;
                    const totalScale = nodScale * scrollScale;

                    heroModel.setAttribute('camera-orbit', `${rotation}deg ${tilt}deg auto`);
                    heroModel.style.transform = `translate(calc(-50% + ${moveX}px), calc(-50% + ${moveY}px)) scale(${totalScale})`;
                } else {
                    // When paused, maintain exact position and scale from pause moment
                    heroModel.style.transform = `translate(calc(-50% + ${pausedMoveX}px), calc(-50% + ${pausedMoveY}px)) scale(${pausedScale})`;
                }

                requestAnimationFrame(animateRotation);
            }

            requestAnimationFrame(animateRotation);
        }
    </script>
</body>
</html>
